commonfields:
  id: CommonServer
  version: -1
name: CommonServer
script: "// Common functions script\n// =======================\n// This script will
  be appended to each server script before being executed.\n// Place here all common
  functions you'd like to share between server scripts.\n/**\n * Returns true if string
  starts with search string\n * @param {String} search - The string to be searched\n
  * @param {Integer} pos - The position in this string at which to begin searching
  for search string; defaults to 0. \n * @return {Boolean} true if string starts with
  <search> string\n */\nif (!String.prototype.startsWith) {\n    String.prototype.startsWith
  = function(search, pos) {\n        return this.substr(!pos || pos < 0 ? 0 : +pos,
  search.length) === search;\n    };\n}\n\n/**\n * Returns true if string ends with
  search string\n * @param {String} search - The string to be searched\n * @param
  {Integer} this_len - Optional. If provided it is used as the length of search string.
  If omitted, the default value is the length of the string.\n * @return {Boolean}
  true if string ends with <search> string\n */\nif (!String.prototype.endsWith) {\n
  \   String.prototype.endsWith = function(search, this_len) {\n        if (this_len
  === undefined || this_len > this.length) {\n            this_len = this.length;\n
  \       }\n        return this.substring(this_len - search.length, this_len) ===
  search;\n    };\n}\n\n/**\n * Removes the final slash / from the given url. This
  function should be used to prevent double slash situations such as https://192.12.12.3:8443//api/\n
  *\n * @param {String} url - e.g https://some_url.com:8080/ or https://some_url.com:8080\n
  * @return {String} url without slash in the end - e.g https://some_url.com:8080\n
  */\nfunction fixUrl(url) {\n    if (url.endsWith('/')) {\n        return url.slice(0,
  -1);\n    }\n\n    return url;\n}\n/**\n * Removes the final slash / from the given
  url. This function should be used to prevent double slash situations such as https://192.12.12.3:8443//api/\n
  *\n * @param {String} url - e.g https://some_url.com:8080/ or https://some_url.com:8080\n
  * @return {String} url without slash in the end - e.g https://some_url.com:8080\n
  */\nvar removeLastSlash = fixUrl;\n\n/**\n * Formats a string in place\n * @return
  {String} The formatted string\n */\nString.prototype.format = function() {\n   var
  content = this;\n   for (var i=0; i < arguments.length; i++)\n   {\n        var
  replacement = '{' + i + '}';\n        content = content.replace(replacement, arguments[i]);\n
  \  }\n   return content;\n}\n\ncleanSingleObject = function(contents) {\n    var
  cleanContents = {};\n    var keys = Object.keys(contents);\n    for (var i = 0;
  i < keys.length; i++) {\n        if (contents[keys[i]] || contents[keys[i]] ===
  false) {\n            cleanContents[keys[i]] = contents[keys[i]];\n        }\n    }\n
  \   return cleanContents;\n}\n\n/**\n * Clean an object from empty fields\n * @param
  {Object} obj - The object to be cleaned\n * @return {Object} The cleaned object\n
  */\nvar cleanObject = function(obj) {\n    if (obj instanceof Array) {\n        var
  res = [];\n        for (var j in obj) {\n            res.push(cleanObject(obj[j]));\n
  \       }\n        return res;\n    }\n    return cleanSingleObject(obj);\n}\n\n/**\n
  \ * Merge a list of objects into a single object.\n  * Note: to avoid loss of data,
  use only on objects with foreign properties.\n  * @param {Array} objs - An array
  of arrays to be merged\n  * @return {Object} the merged array\n  */\nfunction mergeForeignObjects(objs)
  {\n    var merged = {};\n    for (var i in objs) {\n        for (var j in objs[i])
  {\n            merged[j] = objs[i][j];\n        }\n    }\n    return merged;\n}\n\n/**\n
  * Creates a string from an object\n * @param {JSON | String} o - The object to create
  the string from\n * @param {String} [delimiter] - The delimiter of the string representation
  of arrays\n * @return {String} A string which represents the object\n */\nfunction
  objToStr(o, delimiter) {\n    if(!delimiter || typeof(delimiter) !== 'string') {\n
  \             delimiter = ',';\n          }\n    if (Array.isArray(o)) {\n        return
  o.map(function(v) {\n            return objToStr(v);\n        }).join(delimiter);\n
  \   } else if (typeof(o) === 'string') {\n        return o;\n    } else if (typeof(o)
  === 'number') {\n        return '' + o;\n    } else {\n        return JSON.stringify(o);\n
  \   }\n}\n\nMARKDOWN_CHARS = \"\\\\`*_{}[]()#+-!|\"\n\n/**\n * Escapes markdown
  characters in a string\n * @param {String} st - The string to fix\n * @param {Boolean}
  [replaceNewlines] - Should newlines be replaced with '<br>'\n * @return {String}
  A string with the markdown characters escaped\n */\nvar stringEscapeMD = function(st,
  replaceNewlines, minimal_escaping) {\n    if (typeof(st) != 'string') {\n        return
  st;\n    }\n\n    if (replaceNewlines) {\n      st = st.replace(/\\r\\n/g, '<br>');\n
  \     st = st.replace(/\\n/g, '<br>');\n      st = st.replace(/\\r/g, '<br>');\n
  \   }\n\n    var escapedSt = '';\n    if (minimal_escaping) {\n        escapedSt
  = st.replace(/\\|/g, '\\\\|');\n    } else {\n        for (var i = 0; i < st.length;
  i++) {\n            if (MARKDOWN_CHARS.indexOf(st[i]) > -1) {\n                escapedSt
  += '\\\\';\n            }\n            escapedSt += st[i];\n        }\n    }\n\n
  \   return escapedSt;\n};\n\nvar HTML_ENTITY_MAP = {\n  '&': '&amp;',\n  '<': '&lt;',\n
  \ '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n
  \ '=': '&#x3D;'\n};\n\n/**\n * Escapes html characters in a string\n * @param {String}
  st - The string to fix\n * @return {String} A string with the html characters escaped\n
  */\nvar stringEscapeHTML = function(st) {\n    return String(st).replace(/[&<>\"'`=\\/]/g,
  function (s) {\n        return HTML_ENTITY_MAP[s];\n    });\n}\n\n/**\n * Converts
  textual keys to pascal format (e.g. \"Threat Score\" -> \"ThreatScore\")\n * @param
  {Object} dict - The object to be converted\n * @return {Object} The converted object\n
  */\nvar convertKeysToPascalCase = function(dict) {\n    var pascalDict = {};\n    for
  (var key in dict) {\n        var pascalCaseKey = key.replace(/\\w+/g, function(w)
  { return w[0].toUpperCase() + w.slice(1).toLowerCase(); }).replace(/ /g, '');\n
  \       pascalDict[pascalCaseKey] = dict[key];\n    }\n\n    return pascalDict;\n}\n\n/**\n
  * Gets a parameter that can be either an array, a JSON array or a string list separated
  by ',' and returns an array\n * @param {Object} [arg] - The object to be converted\n
  * @return {Array} An array representing the given object\n */\nfunction argToList(arg)
  {\n    if (!arg) {\n        return [];\n    }\n    if (Array.isArray(arg)) {\n        return
  arg;\n    }\n    if (typeof(arg) === 'string') {\n        if (arg[0] === '[' &&
  arg[arg.length - 1] === ']') {\n            return JSON.parse(arg);\n        }\n
  \       return arg.split(',');\n    }\n    return arg;\n}\n\n/**\n * Converts a
  JSON demisto table to a Markdown table\n * @param {String} name - The name of the
  table\n * @param {Object} t - the JSON table - Array of objects with the same keys\n
  * @param {Array|String} [headers] - The output markdown table will show only these
  headers (by order). Use a single string in case of a value type array (Optional).\n
  * @param {String} [cellDelimiter] - The delimiter of the string representation of
  arrays (Optional).\n * @param {Function} [headerTransform] - A transformation function
  for the header keys in the markdown table (Optional).\n * @return {String} A string
  representing the markdown table\n */\nfunction tableToMarkdown(name, t, headers,
  cellDelimiter, headerTransform) {\n    if (t && !(t instanceof Array)){\n        t
  = [t];\n    }\n\n    if(headers && !(headers instanceof Array) && typeof(headers)
  !== 'object'){\n        headers = [headers];\n    }\n\n    //in case of headers
  was not provided (backward compatibility)\n    if ((!(headers) || !(headers instanceof
  Array) || headers.length === 0) && t && t.length > 0 && typeof(t[0]) === 'object')
  {\n        headers = GetAllObjectsProperties(t);\n    }\n\n    if(!headers || !(headers
  instanceof Array) || headers.length === 0) {\n        return 'No data returned\\n';\n
  \   }\n\n    var mdResults = '';\n    if (name) {\n        mdResults = '### ' +
  name + '\\n';\n    }\n    if (t && t.length) {\n        var newHeaders = [];\n        if(!headerTransform){\n
  \         headerTransform = function(string){return string;};\n        }\n        for(var
  i=0; i<headers.length; i++){\n            newHeaders.push(headerTransform(headers[i]));\n
  \       }\n        if (newHeaders.length > 1) {\n            mdResults += newHeaders.join('|')
  + '\\n';\n        } else {\n            mdResults += newHeaders[0] + '|' + '\\n';\n
  \       }\n        var sep = [];\n        headers.forEach(function(h){\n            sep.push('---');\n
  \       });\n        if (sep.length === 1) {\n            sep[0] = sep[0]+'|';\n
  \       }\n        mdResults += sep.join('|') + '\\n';\n        t.forEach(function(entry){\n
  \           var vals = [];\n            if(typeof(entry) !== 'object' && !(entry
  instanceof Array)){\n              var obj = {};\n              obj[headers[0]]
  = entry;\n              entry = obj;\n            }\n            headers.forEach(function(h){\n
  \               if(entry[h] === null || entry[h] === undefined) {\n                    vals.push('
  ');\n                } else {\n                    vals.push(stringEscapeMD(formatCell(entry[h],
  cellDelimiter), true, true) || ' ');\n                }\n            });\n            if
  (vals.length === 1) {\n                vals[0] = vals[0]+'|';\n            }\n            mdResults
  += vals.join('|') + '\\n';\n        });\n    } else{\n        mdResults += 'No data
  returned\\n';\n    }\n    return mdResults;\n}\n\nvar tblToMd = tableToMarkdown;\n\n\n/**\n
  * Converts an array of stings to markdown table\n * @param {Array} arr - from strings\n
  * @param {String} [header] - The output markdown table will show only these headers
  (by order) (Optional).\n * @return {String} A markdown string of tables. If input
  array was empty, will return \"No results\" instead.\n */\nfunction arrayToMarkdownTable(arr,
  header) {\n  if (!arr) {\n      return 'No results';\n  }\n  if (!Array.isArray(arr))
  {\n      throw arr + ' is not an array';\n  }\n  if (arr.length === 0) {\n      return
  'No results';\n  }\n\n  if (typeof arr[0] === 'object') {\n      throw 'arrayToMarkdownTable
  should receive arr which contain objects but simple types like string, int, bool'\n
  \ }\n  if (!header) {\n      throw 'header is required for arrayToMarkdownTable';\n
  \ }\n\n  var md = '|' + header + '|\\n-';\n  arr.forEach(function(item) {\n      md
  += '\\n|' + item + '|';\n  });\n\n  return md;\n}\n\n/**\n * Converts underscore
  case strings to camel case\n * @param {String} string - The string to be converted
  - i.e. hello_world\n * @return {String} - The converted string - i.e. HelloWorld\n*/\nvar
  underscoreToCamelCase = function(string) {\n    var ret_string = '_'+string;\n    return
  ret_string.replace(/_([a-z])/g, function (g) { return g[1].toUpperCase(); });\n};\n\n/**\n
  * Converts dots into spaces and capitalizes\n * @param {String} string - The string
  to be converted - i.e. hello.world\n * @return {String} - The converted string -
  i.e. Hello World\n*/\nvar dotToSpace = function(string) {\n    var ret_string =
  '.'+string;\n    return ret_string.replace(/\\.([a-z,A-Z])/g, function (g) { return
  ' '+g[1].toUpperCase(); });\n};\n\n/**\n * Converts pascal strings to human readable
  (e.g. \"ThreatScore\" -> \"Threat Score\")\n * @param {String} string - The string
  to be converted\n * @return {String} - The converted string\n*/\nvar pascalToSpace
  = function(string) {\n    return string.replace(/([a-z][A-Z])/g, function (g) {
  return g[0] + ' ' + g.slice(1); });\n};\n\nfunction mapObjFunction(mapFields, filter)
  {\n    var transformSingleObj= function(obj) {\n        var res = {};\n        mapFields.forEach(function(f)
  {\n            if(!filter || filter(f)){\n                res[f.to] = dq(obj, f.from);\n
  \           }\n        });\n        return res;\n    };\n    return function(obj)
  {\n        if (obj instanceof Array) {\n            var res = [];\n            for
  (var j=0; j < obj.length; j++) {\n                var current = transformSingleObj(obj[j]);\n
  \               if (current) {\n                    res.push(current);\n                }\n
  \           }\n            return res;\n        }\n        return transformSingleObj(obj);\n
  \   };\n}\n\nfunction createContext(data, id) {\n    var createContextSingle = function(obj)
  {\n        var res = {};\n        var keys = Object.keys(obj);\n        keys.forEach(function(k)
  {\n            var values = k.split('.');\n            var current = res;\n            for
  (var j = 0; j<values.length - 1; j++) {\n                if (!current[values[j]])
  {\n                    current[values[j]] = {};\n                }\n                current
  = current[values[j]];\n            }\n            current[values[j]] = obj[k];\n
  \       });\n        if (!res.ID && id) {\n            res.ID = id;\n        }\n
  \       return res;\n    };\n    if (data instanceof Array) {\n        var res =
  [];\n        for (var j=0; j < data.length; j++) {\n            res.push(createContextSingle(data[j]));\n
  \       }\n        return res;\n    }\n    return createContextSingle(data);\n}\n\nvar
  isFunction = function(functionToCheck) {\n    return functionToCheck && typeof functionToCheck
  === 'function';\n}\n\n/**\n * Creates a dq query string. Used by easyDQ.\n * @param
  {string} path - the path to be parsed\n * @param {function | string} filter - filter
  string (e.g. 'val.id===<some id>'') or filter function (e.g. function(obj){return
  obj.name === 'name';} )\n * @param {function | string} returnValue - string or function
  that defines returned data format (e.g. '{Name : val.name}' or function(val){return
  {Name:val.name};} )\n * @return {string} - the query string to pass to dq function\n*/\nvar
  dqQueryBuilder = function(path, filter, returnValue){\n    var query = path;\n    if(!filter){\n
  \       filter = 'true';\n    }\n    if(isFunction(filter)){\n        filter = filter.toString()
  + '(val)';\n    }\n    if(typeof filter !== 'string'){\n        throw 'dqQueryBuilder:
  Filter type is neither a function nor a string';\n    }\n    query += '('+filter+')';\n
  \   if(returnValue){\n        if(isFunction(returnValue)){\n            returnValue
  = returnValue.toString() + '(val)';\n        }\n        if(typeof returnValue !==
  'string'){\n            throw 'dqQueryBuilder: return value for DQ is neither a
  function nor a string';\n        }\n        query += '='+returnValue;\n    }\n    return
  query;\n};\n\n/**\n * Creates a dq query from arguments and calls dq\n * @param
  {Object} data - The raw data object\n * @param {String} path - The path to be parsed\n
  * @param {Function | String} filter - A filter string (e.g. 'val.id===<some id>'')
  or a filter function (e.g. function(obj){return obj.name === 'name';} )\n * @param
  {Function | String} returnValue - string or function that defines the returned data
  format (e.g. '{Name : val.name}' or function(val){return {Name:val.name};} )\n *
  @return {Object} - The value returned from the dq function\n*/\neasyDQ = function(data,
  path, filter, returnValue){\n    return dq(data, dqQueryBuilder(path, filter, returnValue));\n};\n\n/*
  creates array from obj, if obj is not already an array */\nvar toArray = function(obj){\n
  \   if(obj && !Array.isArray(obj))\n        return [obj];\n    return obj;\n};\n\n/**\n
  * Creates a war room entry\n * @param {Object} result - The raw result to be parsed\n
  * @param {Object} translator - Maps raw data to the war room output. Should be of
  the following format:\n * ```\n * {\n *   contextPath: <context-path>,\n *   title:
  <war-room-title>,\n *   data: [\n *     {to: <dest-key>, from: <orig-key>, (optional)
  humanReadable: <true/false>},\n *     {to: <dest-key>, from: <orig-key>, (optional)
  humanReadable: <true/false>},\n *     ...\n *   ]\n * }\n * ```\n * - dest-key/orig-key
  should be sparated with '.' (e.g. 'File.Malicious')\n * - dest-key is also used
  for war room table headers\n * - humanReadable states whether field should appear
  in war room table. Default is true.\n * @param {function} [MDfilter] - (optional)
  filters out fields that shouldn't be displayed in warroom (returns true/false).
  Default uses humanReadable field.\n * @param {function} [headerTransform] - transform
  mark down headers to readable format.\n * @return {Object} - the war room entry\n*/\nvar
  createEntry = function(result, translator, MDfilter, headerTransform) {\n    /*
  filters out all fields where humanReadable is false */\n    var filter = function(obj)
  {\n        if(obj.humanReadable !== false) {\n            return true;\n        }\n
  \       return false;\n    };\n    if (MDfilter) {\n        filter = MDfilter;\n
  \   }\n\n    var entry = {\n        Type: entryTypes.note,\n        Contents: result,\n
  \       ContentsFormat: formats.json,\n        ReadableContentsFormat: formats.markdown\n
  \   };\n\n    var content = translator.innerPath ? dq(result, translator.innerPath)
  : result;\n    var translatedContext = mapObjFunction(translator.data) (content);\n
  \   var translatedMD = mapObjFunction(translator.data, filter) (content);\n    entry.HumanReadable
  = tableToMarkdown(translator.title, translatedMD, undefined, undefined, headerTransform
  || dotToSpace);\n    entry.EntryContext = {};\n    var context = createContext(translatedContext);\n
  \   entry.EntryContext[translator.contextPath] = context;\n    return entry;\n};\n\n/**\n
  * Converts a demisto table in JSON form to a HTML table\n * @param {String} name
  - the name of the table\n * @param {Object} t - the JSON table - Array of objects
  with the same keys\n * @param {Array} [headers] - optional, the output markdown
  table will show only these headers (by order)\n * @param {String} [cellDelimiter]
  - The delimiter of the string representation of arrays (Optional).\n * @return {String}
  A string representation of the html result\n */\nfunction tableToHTML(name, t, headers,
  cellDelimiter) {\n    if (t && !(t instanceof Array)){\n        t = [t];\n    }\n\n
  \   //in case of headers was not provided (backward compatibility)\n    if ((!headers
  || !headers instanceof Array || headers.length === 0) && t && t.length > 0){\n        headers
  = GetAllObjectsProperties(t);\n    }\n\n    if(!headers || !headers instanceof Array
  || headers.length === 0) {\n        return 'No data returned<br/>';\n    }\n\n    var
  htmlResults = '';\n    if (name) {\n        htmlResults = '<h3>' + name + '</h3><br/>';\n
  \   }\n    if (t && t.length) {\n        htmlResults += '<table><tr>' + headers.reduce(function(acc,
  v) {return acc + '<th>' + v + '</th>';}, '') + '</tr>';\n        t.forEach(function(entry){\n
  \           var vals = [];\n            headers.forEach(function(h){\n                vals.push((!!entry[h]
  || entry[h]==0) ? stringEscapeHTML(formatCell(entry[h], cellDelimiter)) : ' ');\n
  \           });\n            htmlResults += '<tr>' + vals.reduce(function(acc, v)
  {return acc + '<td>' + v + '</td>';}, '') + '</tr>';\n        });\n        htmlResults
  += '</table>';\n    } else{\n        htmlResults += 'No data returned<br/>';\n    }\n
  \   return htmlResults;\n}\n\n/**\n\n* Verifies that the given fields exists in
  the content and verifies its value\n* @param {String} fieldName - the name of the
  field (dq format)\n* @param {Object} expectedValue - the value to verify\n* @param
  {String} [comparisonType] - 'stringContains' or 'stringEquals'. Default is 'stringEquals'\n*
  @return {Object} Returns the value if value at the field matches, throws an error
  an exeption otherwise\n*/\nfunction verifyContextField(fieldName, expectedValue,
  comparisonType) {\n    value = dq(invContext, fieldName);\n\n    if (value === undefined)
  {\n        throw 'Field does not exist: {0}.'.format(fieldName);\n    }\n\n    if
  (expectedValue !== undefined) {\n        if (comparisonType == 'stringContains')
  {\n            if (value.indexOf(expectedValue) == -1) {\n                throw
  'Field {0} does not contain the expected string. Value: {1}, expected: {2}.'.format(fieldName,
  value, expectedValue);\n            }\n        } else {\n            if (value !=
  expectedValue) {\n                throw 'Field {0} does not match. Value: {1}, expected:
  {2}.'.format(fieldName, value, expectedValue);\n            }\n        }\n    }\n\n
  \   return value;\n}\n\n/**\n * Get all properties of objects in an array.\n * @param
  {Array} t - Array of elements\n * @return {Array} - Array of object properties\n*/\nfunction
  GetAllObjectsProperties(t) {\n    var properties = {};\n    t.forEach(function (element)
  {\n        for(var prop in element) {\n            properties[prop] ='';\n        }\n
  \   });\n    return Object.keys(properties).sort();\n}\n\n/**\n * Checks if the
  given string represents a valid IPv4 address\n * @deprecated please use isValidIP
  which really checks IP for validity\n * @param {String} ip - the string to check\n
  * @return {Boolean} true if valid IPv4 address\n */\nfunction isIp(ip) {\n  var
  d = ip.split('.'), i = d.length;\n  if (i !== 4) {\n    return false;\n  }\n  var
  ok = true;\n  while (i-- && ok) {\n    ok = d[i].length !== 0 && !isNaN(parseInt(d[i]))
  && d[i] > -1 && d[i] < 256;\n  }\n  return ok;\n}\n\nvar entryTypes = {note: 1,
  downloadAgent: 2, file: 3, error: 4, pinned: 5, userManagement: 6, image: 7, plagroundError:
  8, entryInfoFile: 9, map: 15, playgroundError: 8};\nvar formats = {html: 'html',
  table: 'table', json: 'json', text: 'text', dbotResponse: 'dbotCommandResponse',
  markdown: 'markdown'};\nvar dbotscores = {critical : 4, high: 3, medium: 2, low:
  1, informational: 0.5, unknown: 0};\n\n/**\n * Returns the name of the file as stored
  in our investigation artifacts on disk.\n * This should be used when sending files
  to d2 scripts as you can see in StaticAnalyze.\n * @param {String} entryId - The
  entry ID containing the file\n * @return {String} The name of the file in our artifact
  repository\n */\nfunction fileNameFromEntry(entryId) {\n  var parts = entryId.split('@');\n
  \ if (parts.length !== 2) {\n    return null;\n  }\n  var res = executeCommand('getEntry',
  {id: entryId});\n  if (res && Array.isArray(res) && res.length === 1) {\n    return
  parts[1] + '_' + res[0].FileID;\n  }\n  return null;\n}\n\n/**\n * Closes the current
  investigation\n * @param {Object} args - Closing details (what happened, damage,
  etc.)\n * @return {Array} An array with an error entry if an error occurred, an
  empty array otherwise\n */\nfunction closeInvestigation(args) {\n  return executeCommand('closeInvestigation',
  args);\n}\n\n/**\n * Sets severity an incident. The incident must be related to
  current investigation.\n * @param {Object} arg - Has 2 keys, 'id' - the incident
  id, 'severity' - the new severity value (Critical, High, Medium etc.).\n * @return
  {Array} An array with an error entry if an error occurred, an empty array otherwise\n
  */\nfunction setSeverity(arg) {\n  return executeCommand('setSeverity', arg);\n}\n\n/**\n
  * Sets fields of the incident. The incident must be related to current investigation
  and be the only incident in it.\n * @param {Object} args - Has 5 optional keys:
  type, severity, details, name and systems of the incident.\n *                        systems
  should follow this string template: '1.1.1.1,10.10.10.10'\n * @return {Array} An
  array with an error entry if an error occurred, an empty array otherwise\n */\nfunction
  setIncident(args) {\n  return executeCommand('setIncident', args);\n}\n\n/**\n *
  Create a new incident with the fields specified, only if an incident with the same
  name does not exist as an active incident.\n * If an active incident with the same
  name exists, ignore the request.\n * @param {Object} args - Has 5 optional keys:
  type, severity, details, name and system of the incident.\n * @return {Array} An
  array with an error entry if an error occurred, an empty array otherwise\n */\nfunction
  createNewIncident(args) {\n  return executeCommand('createNewIncident', args);\n}\n\n/**\n
  * Sets playbook according to type.\n * @param {String} type - The incident type,
  according to which the playbook is chosen\n * @return {Array} An array with an error
  entry if an error occurred, an empty array otherwise\n */\nfunction setPlaybookAccordingToType(type)
  {\n  return executeCommand('setPlaybookAccordingToType', {type: type});\n}\n\n/**\n
  * Sets Owner to an incident. The incident must be related to current investigation.\n
  * @param {Object} name - The user name of the owner\n * @return {Array} An array
  with an error entry if an error occurred, an empty array otherwise\n */\nfunction
  setOwner(name) {\n  return executeCommand('setOwner', { owner: name });\n}\n\n/**\n
  * Assigns a playbook task to a user.\n * @param {Object} arg - Has 2 keys, 'id'
  - the task id, 'assignee' - the user name of the assignee.\n * @return {Array} An
  array with an error entry if an error occurred, an empty array otherwise\n */\nfunction
  taskAssign(arg) {\n  return executeCommand('taskAssign', arg);\n}\n\n/**\n * Sets
  task due date.\n * @param {Object} arg - Has 2 keys, 'id' - the task id, 'dueDate'
  - time string in UTC format (To get current time use: 'new Date().toUTCString()').\n
  * @return {Array} An array with an error entry if an error occurred, an empty array
  otherwise\n */\nfunction setTaskDueDate(arg) {\n  return executeCommand('setTaskDueDate',
  arg);\n}\n\n/**\n * Sets investigation playbook\n * @param {String} name - The playbook
  name.\n * @return {Array} An array with an error entry if an error occurred, an
  empty array otherwise\n */\nfunction setPlaybook(name) {\n  return executeCommand('setPlaybook',
  { name: name });\n}\n\n/**\n * Adds task to Workplan\n * @param {Object} arg - has
  5 keys:\n * - 'name' - (mandatory) The new task's name.\n * - 'description' - (optional)
  The new task's description.\n * - 'script' - (optional) Name of script to be run
  by task.\n * - 'addBefore' - (optional, refers to task id) Insert new task before
  specified task (when using this argument do not use afterTask)\n * - 'addAfter'
  - (optional, refers to task id) Insert new task after specified task (when using
  this argument do not use beforeTask)\n * @return {Array} An array with an error
  entry if an error occurred, an empty array otherwise\n */\nfunction addTask(arg)
  {\n  return executeCommand('addTask', arg);\n}\n\n/**\n * Encode json object to
  URL. Supports multiple arguments of the same value if input is an array.\n * @param
  {Object} args - The object to encode.\n * @return {String} in case of error will
  be empty. In Case of success will return the URL string.\n */\nfunction encodeToURLQuery(args)
  {\n      var query = '';\n      if (args) {\n          var keys = Object.keys(args);\n
  \         if (keys.length > 0) {\n              query = '?';\n              for
  (var i = 0; i<keys.length; i++) {\n                  if (i !== 0) {\n                      query
  += '&';\n                  }\n                  if (Array.isArray(args[keys[i]]))
  {\n                      for (var j=0; j<args[keys[i]].length; j++) {\n                          if
  (j !== 0) {\n                              query += '&';\n                          }\n
  \                         query += encodeURIComponent(keys[i]) + '=' + encodeURIComponent(args[keys[i]][j]);\n
  \                     }\n                  } else {\n                      query
  += encodeURIComponent(keys[i]) + '=' + encodeURIComponent(args[keys[i]]);\n                  }\n
  \             }\n          }\n      }\n      return query;\n}\n\n/**\n * Translate
  ThreatConnect rating to score\n * @param {rating} TC rating as int\n * @return {score}
  Int (between 0 and 3)\n */\nfunction threatConnectRatingToScore(rating) {\n    var
  tcScore = 0;\n    if (rating == 2 || rating == 1) {\n        tcScore = 2;\n    }\n
  \   if (rating > 2) {\n        tcScore = 3;\n    }\n    return tcScore;\n}\n\n/**\n*
  Check the list of available modules to see whether a command is currently available
  to be run.\n* @param {Object} cmd - The command to check.\n* @return {bool} True
  if command is available, false otherwise\n*/\nfunction isCommandAvailable(cmd) {\n
  \   var all = getAllSupportedCommands();\n    var modules = Object.keys(all);\n
  \   for(var i = 0; i < modules.length ; i++) {\n        var modCmds = all[modules[i]];\n
  \       if (modCmds) {\n            for(var j = 0; j < modCmds.length ; j++) {\n
  \               if (modCmds[j].name === cmd) {\n                    return true;\n
  \               }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n
  * Check if the given entry is an error entry\n * @param {Object} entry - The entry
  to check\n * @return {Boolean} True if this is an error entry, false otherwise\n
  */\nfunction isError(entry) {\n  return entry && typeof entry === 'object' && entry.Type
  === entryTypes.error;\n}\n\n/**\n * Check if the given result entry is an array
  and is not an error\n * @param {Array} res - The result from the execute to check\n
  * @return {Boolean} True if this is a valid result\n */\nfunction isValidRes(res)
  {\n  return res && Array.isArray(res) && res.length && !isError(res[0]);\n}\n\n/**\n
  * If the given value exists, return it. Otherwise, return default and if not provided
  'Unknown'\n * @param {Object} v - Value that can be anything\n * @param {Object}
  [def] - Default value. If not provided will be 'Unknown'\n * @return {Object} Value
  if exists, default otherwise\n */\nfunction nvl(v, def) {\n  return v ? v : def
  ? def : 'Unknown';\n}\n\n/**\n * Flatten the fields into a map of dot notation key
  and value\n * @param {Object} obj - The object to iterate on\n * @param {String}
  [path] - (optional) The path so far in dot notation\n * @param {Object} flat - The
  collected object result\n * @return {Object} An object with keys that are dot notation
  and values\n */\nfunction flattenFields(obj, path, flat) {\n  if (obj) {\n      if
  (typeof obj === 'object') {\n          var keys = Object.keys(obj);\n          for
  (var f=0; f<keys.length; f++) {\n              flattenFields(obj[keys[f]], !!path
  ? path + '.' + keys[f] : keys[f], flat);\n          }\n      } else if (Array.isArray(obj))
  {\n          for (var i=0; i<obj.length; i++) {\n              flattenFields(obj[i],
  !!path ? path + '.' + i : '' + i, flat);\n          }\n      } else {\n          flat[path]
  = obj.toString();\n      }\n  }\n}\n\nvar formatCell = objToStr;\n\n/**\n * Convert
  a given object to md while descending multiple levels\n * @param {Object} o - The
  object to convert - can be an array as well\n * @return {String} - The converted
  markdown string\n */\nfunction objToMd(o) {\n    var flat = {};\n    flattenFields(o,
  '', flat);\n    var keys = Object.keys(flat);\n    keys.sort();\n    var md = 'Key
  | Value\\n- | -\\n';\n    for (var i=0; i<keys.length; i++) {\n        md += keys[i]
  + ' | ' + flat[keys[i]] + '\\n';\n    }\n    return md;\n}\n\n/**\n * Convert a
  given object to md list (-) while each value is converted to a simple string\n *
  @param {Object} o - The object to convert\n * @param {String} t - The title of the
  list\n * @return {String} The markdown string\n */\nfunction objToList(o, t) {\n
  \ var md = '';\n  if (o) {\n      md += '### ' + t + '\\n';\n      var keys = Object.keys(o);\n
  \     for (var i=0; i<keys.length; i++) {\n          md += '- ' + keys[i] + ': '
  + objToStr(o[keys[i]]) + '\\n';\n      }\n  }\n  return md;\n}\n\n/**\n* Converts
  the given timestamp to a string\n* @param {int} timestamp - The timestamp in UNIX
  format\n* @return {String} A string representing the time - e.g. 'Thu, 11 May 2017
  11:18:56 UTC'\n*/\nfunction convertTimestampToString(timestamp) {\n  return (new
  Date(parseInt(timestamp))).toISOString();\n}\n\n/**\n* Converts the given number
  (uint32) to an IP address string\n* @param {int} num -  The number to convert\n*
  @return {String} A string representing the IP address - e.g. '192.168.2.1'\n*/\nvar
  numToIp = function(num) {\n  var ip = num % 256;\n\n  for (var i = 3; i > 0; i--)
  {\n      num = Math.floor(num / 256);\n      ip = num % 256 + '.' + ip;\n  }\n\n
  \ return ip;\n}\n\n/**\n * Convert a given array to a markdown table\n * @param
  {Array} arr - The array to convert\n * @return {String} - The converted markdown
  string\n */\nfunction arrToMd(arr) {\n    if (!arr || arr.length === 0) {\n        return
  '';\n    }\n    return tableToMarkdown('', arr);\n}\n\n/**\n * Query the given object
  with the given path and retrive it\n * @deprecated please use dq which has the full
  functionality\n * @param {Object} obj - The object to query\n * @param {String}
  path - The path to retrieve from the object\n * @return {Object} The value of the
  path if the path exists, null otherwise\n */\nfunction jq(obj, path) {\n  if (!obj
  || !path || (typeof obj !== 'object' && !Array.isArray(obj))) {\n    return null;\n
  \ }\n  var parts = path.split('.');\n  for (var i=0; i<parts.length; i++) {\n    //
  First, handle array option\n    var part = parts[i].match(/([a-zA-Z0-9_]*)(\\[([0-9]+)\\])?/);\n
  \   if (part[3]) {\n      // If array of property and not top array\n      if (part[1])
  {\n        if (obj.hasOwnProperty(part[1]) && Array.isArray(obj[part[1]])) {\n          obj
  = obj[part[1]][parseInt(part[3])];\n        } else {\n          return null;\n        }\n
  \     } else {\n        if (Array.isArray(obj)) {\n          obj = obj[parseInt(part[3])];\n
  \       } else {\n          return null;\n        }\n      }\n    } else {\n      //
  Not an array\n      if (obj.hasOwnProperty(part[1])) {\n        obj = obj[part[1]];\n
  \     } else {\n        return null;\n      }\n    }\n  }\n  return obj;\n}\n\n/**\n
  * Replace the given args with the actual values in the input template\n * @param
  {String} input - The template to replace values in\n * @param {Object} args - The
  map of values to use\n * @return {String} The template with the values filled in\n
  */\nfunction replaceInTemplates(input, args) {\n  var res = input;\n  var keys =
  Object.keys(args);\n  for (var i = 0; i < keys.length; i++) {\n    res = res.split('%'
  + keys[i] + '%').join(args[keys[i]]);\n  }\n  return res;\n}\n\n/**\n * Replace
  the given args with the actual values in the input template and remove from args\n
  * @param {String} input - The template to replace values in\n * @param {Object}
  args - The map of values to use\n * @return {String} the template with the values
  filled in\n */\nfunction replaceInTemplatesAndRemove(input, args) {\n    var res
  = input;\n    var keys = Object.keys(args);\n    for (var i = 0; i < keys.length;
  i++) {\n      if (res.indexOf('%' +  keys[i] + '%') !== -1) {\n        res = res.split('%'
  + keys[i] + '%').join(args[keys[i]]);\n        delete(args[keys[i]]);\n      }\n
  \   }\n    return res;\n}\n\nvar xmlReservedChars = {\n  '&': '&amp;',\n  '\\\"':
  '&quot;',\n  '\\'': '&apos;',\n  '<': '&lt;',\n  '>': '&gt;'\n};\n\n/**\n * Escape
  reserved XML chars in the input\n * @param {String} input - The input to escape\n
  * @return {String} The escaped input\n */\nfunction escapeXMLChars(input) {\n    var
  res = input;\n    var keys = Object.keys(xmlReservedChars);\n    for (var i = 0;
  i < keys.length; i++) {\n        res = res.split(keys[i]).join(xmlReservedChars[keys[i]]);\n
  \   }\n    return res;\n}\n\n/**\n * Convert a string representing a comma separated
  list into an array\n * @param {String} listName - The name of the list\n * @return
  {Array} The list as an array\n */\nfunction getCSVListAsArray(listName) {\n    var
  res = executeCommand('getList', {listName: listName});\n    if (isValidRes(res))
  {\n        var data = res[0].Contents.split(',');\n        return data.filter(function(v)
  {return v;}).map(function(v) {return v.trim();});\n    }\n    return [];\n}\n\n/**\n
  * Convert a JSON list/array into an object\n * @param {String} listName - The name
  of the list\n * @return {Object} The JSON as an object\n */\nfunction getJSONListAsObject(listName)
  {\n    var res = executeCommand('getList', {listName: listName});\n    if (isValidRes(res))
  {\n        try {\n            return JSON.parse(res[0].Contents);\n        } catch
  (ex) {\n            throw 'Error parsing list - ' + res[0].Contents + ' - ' + ex;\n
  \       }\n    }\n    return null;\n}\n\nvar brands = {xfe: 'xfe', vt: 'VirusTotal',
  cy: 'cylance', wf: 'WildFire', cs: 'crowdstrike-intel', threatconnect: 'ThreatConnect'};\nvar
  providers = {xfe: 'IBM X-Force Exchange', vt: 'VirusTotal', cy: 'Cylance', wf: 'WildFire',
  cs: 'CrowdStrike'};\n// Thresholds for the various reputation services to mark something
  as positive\nvar thresholds = {xfeScore: 3, vtPositives: 10, vtPositiveUrlsForIP:
  10};\n\n/**\n * Checks if the given entry from a URL reputation query is positive
  (known bad)\n * @deprecated\n * @param {Object} entry - reputation entry\n * @return
  {Boolean} true if positive, false otherwise\n */\nfunction positiveUrl(entry) {\n
  \ if (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json)
  {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe && c && c.url.result.score
  && c.url.result.score > thresholds.xfeScore) {\n      return true;\n    } else if
  (entry.Brand === brands.vt && c && c.positives && c.positives > thresholds.vtPositives)
  {\n      return true;\n    } else if (entry.Brand === brands.cs && c && c.length
  && c[0].indicator && (c[0].malicious_confidence === 'high' || c[0].malicious_confidence
  === 'medium')) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n *
  Checks if the given entry from a file reputation query is positive (known bad)\n
  * @deprecated\n * @param {Object} entry - reputation entry\n * @return {Boolean}
  true if positive, false otherwise\n */\nfunction positiveFile(entry) {\n  if (entry.Type
  !== entryTypes.error && entry.ContentsFormat === formats.json) {\n    var c = entry.Contents;\n
  \   if (entry.Brand === brands.xfe && c && c.malware.family) {\n      return true;\n
  \   } else if (entry.Brand === brands.vt && c && c.positives && c.positives > thresholds.vtPositives)
  {\n      return true;\n    } else if (entry.Brand === brands.wf && c && c.wildfire
  && c.wildfire.file_info) {\n      return c.wildfire.file_info.malware === 'yes';\n
  \   } else if (entry.Brand === brands.cy && c) {\n      var k = Object.keys(c);\n
  \     if (k && k.length > 0) {\n        var v = c[k[0]];\n        if (v && v.generalscore)
  {\n          return v.generalscore < -0.5;\n        }\n      }\n    } else if (entry.Brand
  === brands.cs && c && c.length && c[0].indicator && (c[0].malicious_confidence ===
  'high' || c[0].malicious_confidence === 'medium')) {\n      return true;\n    }\n
  \ }\n  return false;\n}\n\n/**\n * Checks if the given entry from an IP reputation
  query is positive (known bad)\n * @deprecated\n * @param {Object} entry - reputation
  entry\n * @return {Boolean} true if positive, false otherwise\n */\nfunction positiveIP(entry)
  {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json)
  {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe && c && c.reputation.score
  && c.reputation.score > thresholds.xfeScore) {\n      return true;\n    } else if
  (entry.Brand === brands.vt && c && c.detected_urls) {\n      var positives = 0;\n
  \     for (var i = 0; i < c.detected_urls.length; i++) {\n        if (c.detected_urls[i].positives
  > thresholds.vtPositives) {\n          positives++;\n        }\n      }\n      return
  positives > thresholds.vtPositiveUrlsForIP;\n    } else if (entry.Brand === brands.cs
  && c && c.length && c[0].indicator && (c[0].malicious_confidence === 'high' || c[0].malicious_confidence
  === 'medium')) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n *
  Display CrowdStrike Intel results in Markdown\n * @deprecated\n * @param {Object}
  entry - reputation entry\n * @return {Object} the markdown entry\n */\nfunction
  shortCrowdStrike(entry) {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat
  === formats.json) {\n    var c = entry.Contents;\n    if (entry.Brand === brands.cs
  && c && c.length && c[0].indicator) {\n      var csRes = '## CrowdStrike Falcon
  Intelligence';\n      csRes += '\\n\\n### Indicator - ' + c[0].indicator;\n      if
  (c[0].labels && c[0].labels.length) {\n        csRes += '\\n### Labels';\n        csRes
  += '\\nName|Created|Last Valid';\n        csRes += '\\n----|-------|----------';\n
  \       for (var l = 0; l < c[0].labels.length; l++) {\n          csRes += '\\n'
  + c[0].labels[l].name + '|' + new Date(c[0].labels[l].created_on * 1000) + '|' +
  new Date(c[0].labels[l].last_valid_on * 1000);\n        }\n      }\n      if (c[0].relations
  && c[0].relations.length) {\n        csRes += '\\n### Relations';\n        csRes
  += '\\nIndicator|Type|Created|Last Valid';\n        csRes += '\\n---------|----|-------|----------';\n
  \       for (var r = 0; r < c[0].relations.length; r++) {\n          csRes += '\\n'
  + c[0].relations[r].indicator + '|' + c[0].relations[r].type + '|' + new Date(c[0].relations[r].created_date
  * 1000) + '|' + new Date(c[0].relations[r].last_valid_date * 1000);\n        }\n
  \     }\n      return {ContentsFormat: formats.markdown, Type: entryTypes.note,
  Contents: csRes};\n    }\n  }\n  return entry;\n}\n\n/**\n * Formats a URL reputation
  entry into a short table\n * @deprecated\n * @param {Object} entry - reputation
  entry\n * @return {Object} the table entry\n */\nfunction shortUrl(entry) {\n  if
  (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json) {\n    var
  c = entry.Contents;\n    if (entry.Brand === brands.xfe && c) {\n      return {ContentsFormat:
  formats.table, Type: entryTypes.note, Contents: {\n        Country: c.country, MalwareCount:
  c.malware.count, A: c.resolution.A ? c.resolution.A.join(',') : '',\n        AAAA:
  c.resolution.AAAA ? c.resolution.AAAA.join(',') : '', Score: c.url.result.score,\n
  \       Categories: c.url.result.cats ? Object.keys(c.url.result.cats).join(',')
  : '',\n        URL: c.url.result.url, Provider: providers.xfe, ProviderLink: 'https://exchange.xforce.ibmcloud.com/url/'
  + c.url.result.url\n      }};\n    } else if (entry.Brand === brands.vt && c) {\n
  \     return {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n
  \       ScanDate: c.scan_date, Positives: c.positives, Total: c.total, URL: c.url,
  Provider: providers.vt, ProviderLink: c.permalink\n      }};\n    } else if (entry.Brand
  === brands.cs && c && c.length && c[0].indicator) {\n      return shortCrowdStrike(entry);\n
  \   } else if (entry.Brand === brands.threatconnect && c && c.data && c.data.url)
  {\n      var url = c.data.url;\n      return {ContentsFormat: formats.table, Type:
  entryTypes.note, Contents: {\n        Url: url.text, Rating: url.rating, Confidence:
  url.confidence,\n        DateAdded: url.dateAdded, ID: url.id, webLink: url.webLink,
  Provider: entry.Brand\n      }};\n    }\n  }\n  return entry;\n}\n\n/**\n * Formats
  a file reputation entry into a short table\n * @deprecated\n * @param {Object} entry
  - reputation entry\n * @return {Object} the table entry\n */\nfunction shortFile(entry)
  {\n  if (entry.Type !== entryTypes.error && entry.ContentsFormat === formats.json)
  {\n    var c = entry.Contents;\n    if (entry.Brand === brands.xfe && entry.Contents)
  {\n      var cm = c.malware;\n      return {ContentsFormat: formats.table, Type:
  entryTypes.note, Contents: {\n        Family: cm.family, MIMEType: cm.mimetype,
  MD5: cm.md5 ? cm.md5.substring(2) : '',\n        CnCServers: cm.origins.CnCServers.count,
  DownloadServers: cm.origins.downloadServers.count,\n        Emails: cm.origins.emails.count,
  ExternalFamily: cm.origins.external && cm.origins.external.family ? cm.origins.external.family.join(',')
  : '',\n        ExternalCoverage: cm.origins.external.detectionCoverage, Provider:
  providers.xfe,\n        ProviderLink: 'https://exchange.xforce.ibmcloud.com/malware/'
  + cm.md5.replace(/^(0x)/,\"\")\n      }};\n    } else if (entry.Brand === brands.vt
  && entry.Contents) {\n      return {ContentsFormat: formats.table, Type: entryTypes.note,
  Contents: {\n        Resource: c.resource, ScanDate: c.scan_date, Positives: c.positives,
  Total: c.total, SHA1: c.sha1, SHA256: c.sha256, Provider: providers.vt, ProviderLink:
  c.permalink\n      }};\n    } else if (entry.Brand === brands.cy && entry.Contents)
  {\n      var k = Object.keys(entry.Contents);\n      if (k && k.length > 0) {\n
  \       var v = entry.Contents[k[0]];\n        if (v) {\n          return {ContentsFormat:
  formats.table, Type: entryTypes.note, Contents: {\n            Status: v.status,
  Code: v.statuscode, Score: v.generalscore, Classifiers: JSON.stringify(v.classifiers),
  ConfirmCode: v.confirmcode, Error: v.error, Provider: providers.cy\n          }};\n
  \       }\n      }\n    } else if (entry.Brand === brands.wf && entry.Contents &&
  entry.Contents.wildfire && entry.Contents.wildfire.file_info) {\n      var c = entry.Contents.wildfire.file_info;\n
  \     return {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n
  \       Type: c.filetype, Malware: c.malware, MD5: c.md5, SHA256: c.sha256, Size:
  c.size, Provider: providers.wf\n      }};\n    } else if (entry.Brand === brands.cs
  && c && c.length && c[0].indicator) {\n      return shortCrowdStrike(entry);\n    }
  else if (entry.Brand === brands.threatconnect && c && c.data && c.data.file) {\n
  \     var file = c.data.file;\n      return {ContentsFormat: formats.table, Type:
  entryTypes.note, Contents: {\n        File: file.file, Rating: file.rating, Confidence:
  file.confidence, Sha256: file.sha256, Sha1: file.sha1, MD5: file.md5,\n        DateAdded:
  file.dateAdded, ID: file.id, webLink: file.webLink, Provider: entry.Brand\n      }};\n
  \   }\n  }\n  return entry;\n}\n\n/**\n * Formats an ip reputation entry into a
  short table\n * @deprecated\n * @param {Object} entry - reputation entry\n * @return
  {Object} the table entry\n */\nfunction shortIP(entry) {\n  if (entry.Type !== entryTypes.error
  && entry.ContentsFormat === formats.json) {\n    var c = entry.Contents;\n    if
  (entry.Brand === brands.xfe && entry.Contents) {\n      var cr = c.reputation;\n
  \     return {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n
  \       IP: cr.ip, Score: cr.score, Geo: cr.geo && cr.geo['country'] ? cr.geo['country']
  : '',\n        Categories: cr.cats ? JSON.stringify(cr.cats) : '', Provider: providers.xfe\n
  \     }};\n    } else if (entry.Brand === brands.vt && entry.Contents) {\n      var
  positives = 0;\n      for (var i = 0; i < entry.Contents.detected_urls.length; i++)
  {\n        if (entry.Contents.detected_urls[i].positives > thresholds.vtPositives)
  {\n          positives++;\n        }\n      }\n      return {ContentsFormat: formats.table,
  Type: entryTypes.note, Contents: {\n        DetectedURLs: positives, Provider: providers.vt\n
  \     }};\n    } else if (entry.Brand === brands.cs && c && c.length && c[0].indicator)
  {\n      return shortCrowdStrike(entry);\n    } else if (entry.Brand === brands.threatconnect
  && c && c.data && c.data.address) {\n      var addr = c.data.address;\n      return
  {ContentsFormat: formats.table, Type: entryTypes.note, Contents: {\n        IP:
  addr.ip, Rating: addr.rating, Confidence: addr.confidence,\n        DateAdded: addr.dateAdded,
  ID: addr.id, webLink: addr.webLink, Provider: entry.Brand\n      }};\n    }\n  }\n
  \ return entry;\n}\n\n/**\n * Formats a domain reputation entry into a short table\n
  * @deprecated\n * @param {Object} entry - reputation entry\n * @return {Object}
  the table entry\n */\nfunction shortDomain(entry) {\n  if (entry.Type !== entryTypes.error
  && entry.ContentsFormat === formats.json) {\n    if (entry.Brand === brands.vt &&
  entry.Contents) {\n      var c = entry.Contents;\n      var positives = 0;\n      for
  (var i = 0; i < entry.Contents.detected_urls.length; i++) {\n        if (entry.Contents.detected_urls[i].positives
  > 20) {\n          positives++;\n        }\n      }\n      return {ContentsFormat:
  formats.table, Type: entryTypes.note, Contents: {\n        DetectedURLs: positives,
  Provider: providers.vt\n      }};\n    }\n  }\n  return entry;\n}\n\n/**\n * Flatten
  a JSON tree object to key-value format\n * @param {Object} object - The object to
  be flattened\n * @return {Object} the formatted object (key-value format)\n */\nvar
  treeToFlattenObject = function(object) {\n    if(typeof object !== 'object' && !(Array.isArray(object))){\n
  \       return object;\n    }\n    var retVal = {};\n\n    for (var i in object)
  {\n        if (!object.hasOwnProperty(i)) continue;\n        if ((typeof object[i])
  == 'object' && (!Array.isArray(object[i]) || !(object[i].length == 0 || (typeof
  object[i][0] != 'object')))) {\n            var flatObject = treeToFlattenObject(object[i]);\n
  \           for (var x in flatObject) {\n                if (!flatObject.hasOwnProperty(x))
  continue;\n                retVal[i + '.' + x] = flatObject[x];\n            }\n
  \       } else {\n            retVal[i] = object[i];\n        }\n    }\n    return
  retVal;\n};\n\n\n/**\n * Base64 encode utiliy. Use Base64.encode(<value>) to encode
  a string into base64\n * @return A base64 encoded string\n */\nvar Base64 = {\n
  \     _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n
  \     encode: function(input) {\n        var output = \"\";\n        var chr1, chr2,
  chr3, enc1, enc2, enc3, enc4;\n        var i = 0;\n        while (i < input.length)
  {\n          chr1 = input.charCodeAt(i++);\n          chr2 = input.charCodeAt(i++);\n
  \         chr3 = input.charCodeAt(i++);\n          enc1 = chr1 >> 2;\n          enc2
  = ((chr1 & 3) << 4) | (chr2 >> 4);\n          enc3 = ((chr2 & 15) << 2) | (chr3
  >> 6);\n          enc4 = chr3 & 63;\n          if (isNaN(chr2)) {\n            enc3
  = enc4 = 64;\n          } else if (isNaN(chr3)) {\n            enc4 = 64;\n          }\n
  \         output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2)
  + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n        }\n\n        return
  output;\n      }\n};\n\n/**\n * Add the given obj to the path while making sure
  to append Malicious property\n * @param {Object} context - The current war room
  context, to which the value should be added\n * @param {String} path - The context
  path in which the object shoud be added\n * @param {Object} obj - The object to
  be flattened\n * @return {Undefined} The function does not return a value\n */\nfunction
  addMalicious(context, path, obj) {\n    obj['properties_to_append'] = ['Malicious'];\n
  \   context[path] = obj;\n}\n\n// Constants for common merge paths\nvar outputPaths
  = {\n    file: 'File(val.MD5 && val.MD5 === obj.MD5 || val.SHA1 && val.SHA1 ===
  obj.SHA1 || val.SHA256 && val.SHA256 === obj.SHA256)',\n    ip: 'IP(val.Address
  && val.Address === obj.Address)',\n    url: 'URL(val.Data && val.Data === obj.Data)',\n
  \   domain: 'Domain(val.Name && val.Name === obj.Name)',\n    cve: 'CVE(val.ID &&
  val.ID === obj.ID)',\n    email: 'Account.Email(val.Address && val.Address === obj.Address)'\n};\n\n\n/**\n
  * Converts score (in number format) to human readable reputation format\n * @param
  {Int} score - The score to be formatted\n * @return {String} The formatted score\n
  */\nfunction scoreToReputation(score) {\n    if (score === 3){\n        return 'Bad';\n
  \   }\n    if (score === 2){\n        return 'Suspicious';\n    }\n    if (score
  === 1){\n        return 'Good';\n    }\n    return 'None';\n};\n\n/**\n * Check
  if the given IP address is in the given subnet\n * @param {String} ip - The IP address\n
  * @param {String} subnet - The subnet\n * @return {String} True if IP is in the
  subnet, false otherwise\n */\nfunction isIPInSubnet(ip, subnet) {\n    function
  IPnumber(IPaddress) {\n        var parsedIp = IPaddress.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n
  \       if(parsedIp) {\n            return (+parsedIp[1]<<24) + (+parsedIp[2]<<16)
  + (+parsedIp[3]<<8) + (+parsedIp[4]);\n        }\n        return null;\n    }\n\n
  \   function IPmask(maskSize) {\n        return -1<<(32-maskSize);\n    }\n\n    var
  parts = subnet.split('/');\n    if (parts.length == 1) {\n        return ip == parts[0];\n
  \   }\n    if (IPnumber(parts[0]) && parts[1].match(/^(\\d+)/)) {\n        return
  (IPnumber(ip) & IPmask(parts[1])) == IPnumber(parts[0]);\n    }\n    return false;\n}\n\n/**\n
  * Converts all cells in a JSON form Demisto table to human-readable strings\n *
  @param {Object} obj - The Demisto table\n * @return {Object} - A new Demisto table
  containing the same fields as formatted strings\n */\nfunction formatTableValues(obj)
  {\n\n  /* Helper function to reduces multiples newlines in a string */\n  var reduceNewlines
  = function(str) {\n      var res = str;\n      while (res.indexOf('\\n\\n\\n') !=
  -1) {\n          res = res.replace('\\n\\n\\n', '\\n\\n');\n      }\n      return
  res;\n  }\n\n  /* Helper function that handles the padding of new lines by depth
  */\n  var indent = function(depth) {\n      var res = ''\n      for (var i = 0;
  i < (depth || 0); i++) {\n          res += '  ';\n      }\n      return res;\n  }\n\n
  \ /* Helper function that rucurses an object, formatting it's values as strings
  */\n  var formatTableValuesRecursive = function(obj, depth) {\n      var res = '';\n\n
  \     /* Return non objects (or dates) as strings */\n      if (!obj || typeof obj
  !== 'object' || !Object.keys(obj).length) {\n            return indent(depth ||
  0) + obj + '\\n';  // this will always convert to string type\n      }\n\n      /*
  Recurse all object keys, formatting values as independent lines, increasing depth
  with each call */\n      Object.keys(obj).forEach(function(key) {\n          var
  value = obj[key];\n          var isArrayElement = obj instanceof Array;\n\n          /*
  Handle object values in a new call */\n          if (typeof value === 'object')
  {\n              if (isArrayElement) {\n                  res += formatTableValuesRecursive(value,
  (depth || 0)) + '\\n';\n              } else {\n                  res += indent(depth)
  + key + '\\n';\n                  res += formatTableValuesRecursive(value, (depth
  || 0) + 1) + '\\n';\n              }\n          } else {\n              /* Format
  primitives as a string */\n              var keyStr = (isArrayElement) ? (parseInt(key)
  + 1) : key;    // 1-based indexing for arrays for better readability\n              res
  += indent(depth) + keyStr + ': ' + value + '\\n';\n          }\n      });\n\n      res
  = reduceNewlines(res);\n      return res;\n  }\n\n  /* Run all object keys and invoke
  the recursive helper function */\n  if (!obj || typeof obj !== 'object' || !Object.keys(obj).length)
  {\n      return obj;\n  }\n  var res = {};\n  Object.keys(obj).forEach(function(key)
  {\n      var str = formatTableValuesRecursive(obj[key]);\n      str = str.trim('\\n');
  \  //There's no need for a newline at the end of the entire stirng\n      res[key]
  = str;\n  });\n\n  return res;\n}\n\n/********************************** Date Formatting
  **************************************/\n/* Date formats\n  %d - day 01, 02 ...
  31\n  %m - month 01, 02 .. 12\n  %y - 95, 17\n  %Y - year 1995, 2017\n  %H - hour
  01, 02 .. 24\n  %M - minute 01, 02 .. 60\n  %S - seconds 01, 02 .. 60\n  %f - millisecond
  001, 002, 003 ... 999\n  %z - timezone (empty), +0000, -0400, +1030\n  %Z - timezone
  (empty), UTC, EST, CST\n*/\nvar month_names_short = {\n    'Jan': 1, 'Feb': 2, 'Mar':
  3, 'Apr': 4, 'May': 5, 'Jun':6, 'Jul':7, 'Aug':8, 'Sep':9, 'Oct':20, 'Nov':11, 'Dec':0\n};\n\n/**\n
  * Formats a date object to a string according to the given format.\n * @deprecated\n
  * @param {Date} date - The date object to be formatted\n * @param {Date} format
  - The format string. Should be a legal python datetime format (e.g. \"%d %Y %H:%M:%S\")\n
  * @return {string} A string representation of date object according to format\n
  */\nfunction dateToString(date, format) {\n    if (!date || !(date instanceof Date)
  || typeof date.getMonth !== 'function' || String(date.getDate()) === 'NaN') {\n
  \       throw date + ' must be of type Date';\n    }\n\n    var dateString = format;\n
  \   if (format.indexOf('%d') > -1) {\n        if (Number(date.getDate()) < 10) {\n
  \           dateString = dateString.replace('%d', '0' + date.getDate());\n        }
  else {\n            dateString = dateString.replace('%d', date.getDate());\n        }\n
  \   }\n    if (format.indexOf('%m') > -1) {\n        if (Number(date.getMonth())
  + 1 < 10) {\n            dateString = dateString.replace('%m', '0' + (date.getMonth()
  + 1));\n        } else {\n            dateString = dateString.replace('%m', date.getMonth()
  + 1);\n        }\n    }\n    if (format.indexOf('%y') > -1) {\n        if (Number(date.getYear())
  < 10) {\n            dateString = dateString.replace('%y', '0' + date.getYear());\n
  \       } else {\n            dateString = dateString.replace('%y', date.getYear());\n
  \       }\n    }\n    if (format.indexOf('%Y') > -1) {\n        dateString = dateString.replace('%Y',
  date.getFullYear());\n    }\n    if (format.indexOf('%H') > -1) {\n        if (date.getHours()
  < 10) {\n            dateString = dateString.replace('%H', '0' + date.getHours());\n
  \       } else {\n            dateString = dateString.replace('%H', date.getHours());\n
  \       }\n    }\n    if (format.indexOf('%M') > -1) {\n        if (date.getMinutes()
  < 10) {\n            dateString = dateString.replace('%M', '0' + date.getMinutes());\n
  \       } else {\n            dateString = dateString.replace('%M', date.getMinutes());\n
  \       }\n    }\n    if (format.indexOf('%S') > -1) {\n        if (date.getSeconds()
  < 10) {\n            dateString = dateString.replace('%S', '0' + date.getSeconds());\n
  \       } else {\n            dateString = dateString.replace('%S', date.getSeconds());\n
  \       }\n    }\n    if (format.indexOf('%f') > -1) {\n        if (date.getMilliseconds()
  < 10) {\n            dateString = dateString.replace('%f', '00' + date.getMilliseconds());\n
  \       } else if (date.getMilliseconds() < 100) {\n            dateString = dateString.replace('%f',
  '0' + date.getMilliseconds());\n        } else {\n            dateString = dateString.replace('%f',
  date.getMilliseconds());\n        }\n    }\n\n    return dateString;\n}\n\n/**\n
  * Parses date string to date object.\n * @deprecated\n * @param {string} dateString
  - date as string\n * @param {string} format - the dateString must fit the format.\n
  * format is according to date format of python datetime library\n * @return {Date}
  parsed date object\n */\nfunction stringToDate(dateString, format) {\n    if (typeof
  dateString !== 'string') {\n        throw dateString  + ' must be string';\n    }
  else if (typeof format !== 'string') {\n        throw format + ' must be string';\n
  \   }\n\n    var newDate = new Date(1970, 0, 1, 0, 0, 0, 0);\n    var newString
  = dateString;\n    var delta = 0;\n    for(var i = 0; i < format.length - 1; i++)
  {\n        switch (format.charAt(i) + format.charAt(i + 1)) {\n            case
  '%d':\n                var d = newString.substring(delta + i, delta + i + 2);\n
  \               newDate.setDate(Number(d));\n                break;\n            case
  '%m':\n                var m = newString.substring(delta + i, delta + i + 2);\n
  \               newDate.setMonth(Number(m) - 1);\n                break;\n            case
  '%b':\n                var b = newString.substring(delta + i, delta + i + 3);\n
  \               var month = month_names_short[b];\n                newDate.setMonth(month
  - 1);\n                delta += 1;\n                break;\n            case '%y':\n
  \               var y = newString.substring(delta + i, delta + i + 2);\n                newDate.setYear('20'
  + y);\n                break;\n            case '%Y':\n                var Y = newString.substring(delta
  + i, delta + i + 4);\n                newDate.setFullYear(Y);\n                delta
  += 2;\n                break;\n            case '%H':\n                var H = newString.substring(delta
  + i, delta + i + 2);\n                newDate.setHours(H);\n                break;\n
  \           case '%M':\n                var M = newString.substring(delta + i, delta
  + i + 2);\n                newDate.setMinutes(M);\n                break;\n            case
  '%S':\n                var S = newString.substring(delta + i, delta + i + 2);\n
  \               newDate.setSeconds(S);\n                break;\n            case
  '%f':\n                var f = newString.substring(delta + i, delta + i + 3);\n
  \               newDate.setMilliseconds(f);\n                delta += 1;\n                break;\n
  \       }\n    }\n\n    return newDate;\n}\n\n/**********************************
  Date Formatting end **************************************/\n\n/**********************************
  HMAC_SHA256 **************************************/\n\n    /* string_to_array: convert
  a string to a character (byte) array */\n    function string_to_array(str) {\n      var
  len = str.length;\n      var res = new Array(len);\n      for(var i = 0; i < len;
  i++)\n        res[i] = str.charCodeAt(i);\n      return res;\n    }\n\n    /* array_to_hex_string:
  convert a byte array to a hexadecimal string */\n    function array_to_hex_string(ary)
  {\n      var res = \"\";\n      for(var i = 0; i < ary.length; i++)\n        res
  += SHA256_hexchars[ary[i] >> 4] + SHA256_hexchars[ary[i] & 0x0f];\n      return
  res;\n    }\n\n\n    /* The following are the SHA256 routines */\n\n    /*\n       SHA256_init:
  initialize the internal state of the hash function. Call this\n       function before
  calling the SHA256_write function.\n    */\n\n    function SHA256_init() {\n      SHA256_H
  = new Array(0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f,
  0x9b05688c, 0x1f83d9ab, 0x5be0cd19);\n      SHA256_buf = new Array();\n      SHA256_len
  = 0;\n    }\n\n    /*\n       SHA256_write: add a message fragment to the hash function's
  internal state.\n       'msg' may be given as string or as byte array and may have
  arbitrary length.\n\n    */\n\n    function SHA256_write(msg) {\n      if (typeof(msg)
  == \"string\")\n        SHA256_buf = SHA256_buf.concat(string_to_array(msg));\n
  \     else\n        SHA256_buf = SHA256_buf.concat(msg);\n      for(var i = 0; i
  + 64 <= SHA256_buf.length; i += 64)\n        SHA256_Hash_Byte_Block(SHA256_H, SHA256_buf.slice(i,
  i + 64));\n      SHA256_buf = SHA256_buf.slice(i);\n      SHA256_len += msg.length;\n
  \   }\n\n    /*\n       SHA256_finalize: finalize the hash value calculation. Call
  this function\n       after the last call to SHA256_write. An array of 32 bytes
  (= 256 bits)\n       is returned.\n    */\n\n    function SHA256_finalize() {\n
  \     SHA256_buf[SHA256_buf.length] = 0x80;\n\n      if (SHA256_buf.length > 64
  - 8) {\n        for(var i = SHA256_buf.length; i < 64; i++)\n          SHA256_buf[i]
  = 0;\n        SHA256_Hash_Byte_Block(SHA256_H, SHA256_buf);\n        SHA256_buf.length
  = 0;\n      }\n\n      for(var i = SHA256_buf.length; i < 64 - 5; i++)\n        SHA256_buf[i]
  = 0;\n        SHA256_buf[59] = (SHA256_len >>> 29) & 0xff;\n        SHA256_buf[60]
  = (SHA256_len >>> 21) & 0xff;\n        SHA256_buf[61] = (SHA256_len >>> 13) & 0xff;\n
  \       SHA256_buf[62] = (SHA256_len >>> 5) & 0xff;\n        SHA256_buf[63] = (SHA256_len
  << 3) & 0xff;\n        SHA256_Hash_Byte_Block(SHA256_H, SHA256_buf);\n        var
  res = new Array(32);\n\n        for(var i = 0; i < 8; i++) {\n            res[4
  * i + 0] = SHA256_H[i] >>> 24;\n            res[4 * i + 1] = (SHA256_H[i] >> 16)
  & 0xff;\n            res[4 * i + 2] = (SHA256_H[i] >> 8) & 0xff;\n            res[4
  * i + 3] = SHA256_H[i] & 0xff;\n        }\n\n        SHA256_H = undefined;\n        SHA256_buf
  = undefined;\n        SHA256_len = undefined;\n        return res;\n    }\n\n    /*\n
  \      SHA256_hash: calculate the hash value of the string or byte array 'msg'\n
  \      and return it as hexadecimal string. This shortcut function may be more\n
  \      convenient than calling SHA256_init, SHA256_write, SHA256_finalize\n       and
  array_to_hex_string explicitly.\n    */\n\n    function SHA256_hash(msg) {\n      var
  res;\n      SHA256_init();\n      SHA256_write(msg);\n      res = SHA256_finalize();\n
  \     return array_to_hex_string(res);\n    }\n\n    /* The following are the HMAC-SHA256
  routines */\n\n    /*\n       HMAC_SHA256_init: initialize the MAC's internal state.
  The MAC key 'key'\n       may be given as string or as byte array and may have arbitrary
  length.\n    */\n\n    function HMAC_SHA256_init(key) {\n      if (typeof(key) ==
  \"string\")\n        HMAC_SHA256_key = string_to_array(key);\n      else\n        HMAC_SHA256_key
  = new Array().concat(key);\n\n      if (HMAC_SHA256_key.length > 64) {\n        SHA256_init();\n
  \       SHA256_write(HMAC_SHA256_key);\n        HMAC_SHA256_key = SHA256_finalize();\n
  \     }\n\n      for(var i = HMAC_SHA256_key.length; i < 64; i++)\n        HMAC_SHA256_key[i]
  = 0;\n      for(var i = 0; i < 64; i++)\n        HMAC_SHA256_key[i] ^=  0x36;\n
  \     SHA256_init();\n      SHA256_write(HMAC_SHA256_key);\n    }\n\n    /*\n       HMAC_SHA256_write:
  process a message fragment. 'msg' may be given as\n       string or as byte array
  and may have arbitrary length.\n    */\n\n    function HMAC_SHA256_write(msg) {\n
  \     SHA256_write(msg);\n    }\n\n    /*\n       HMAC_SHA256_finalize: finalize
  the HMAC calculation. An array of 32 bytes\n       (= 256 bits) is returned.\n    */\n\n
  \   function HMAC_SHA256_finalize() {\n      var md = SHA256_finalize();\n      for(var
  i = 0; i < 64; i++)\n        HMAC_SHA256_key[i] ^= 0x36 ^ 0x5c;\n      SHA256_init();\n
  \     SHA256_write(HMAC_SHA256_key);\n      SHA256_write(md);\n      for(var i =
  0; i < 64; i++)\n        HMAC_SHA256_key[i] = 0;\n      HMAC_SHA256_key = undefined;\n
  \     return SHA256_finalize();\n    }\n\n    /*\n       HMAC_SHA256_MAC: calculate
  the HMAC value of message 'msg' under key 'key'\n       (both may be of type string
  or byte array); return the MAC as hexadecimal\n       string. This shortcut function
  may be more convenient than calling\n       HMAC_SHA256_init, HMAC_SHA256_write,
  HMAC_SHA256_finalize and\n       array_to_hex_string explicitly.\n    */\n\n    function
  HMAC_SHA256_MAC(key, msg) {\n      var res;\n      HMAC_SHA256_init(key);\n      HMAC_SHA256_write(msg);\n
  \     res = HMAC_SHA256_finalize();\n      return array_to_hex_string(res);\n    }\n\n
  \   /* The following lookup tables and functions are for internal use only! */\n\n
  \   SHA256_hexchars = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n
  \     'a', 'b', 'c', 'd', 'e', 'f');\n\n    SHA256_K = new Array(\n      0x428a2f98,
  0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n      0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n      0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
  0xc19bf174, 0xe49b69c1, 0xefbe4786,\n      0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa,
  0x5cb0a9dc, 0x76f988da,\n      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3,
  0xd5a79147,\n      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n
  \     0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n
  \     0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n
  \     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n
  \     0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n
  \     0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    );\n\n    function SHA256_sigma0(x)
  {\n      return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);\n
  \   }\n\n    function SHA256_sigma1(x) {\n      return ((x >>> 17) | (x << 15))
  ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);\n    }\n\n    function SHA256_Sigma0(x)
  {\n      return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^\n        ((x
  >>> 22) | (x << 10));\n    }\n\n    function SHA256_Sigma1(x) {\n      return ((x
  >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^\n        ((x >>> 25) | (x << 7));\n
  \   }\n\n    function SHA256_Ch(x, y, z) {\n      return z ^ (x & (y ^ z));\n    }\n\n
  \   function SHA256_Maj(x, y, z) {\n      return (x & y) ^ (z & (x ^ y));\n    }\n\n
  \   function SHA256_Hash_Word_Block(H, W) {\n      for(var i = 16; i < 64; i++)\n
  \       W[i] = (SHA256_sigma1(W[i - 2]) +  W[i - 7] +\n          SHA256_sigma0(W[i
  - 15]) + W[i - 16]) & 0xffffffff;\n      var state = new Array().concat(H);\n      for(var
  i = 0; i < 64; i++) {\n        var T1 = state[7] + SHA256_Sigma1(state[4]) +\n          SHA256_Ch(state[4],
  state[5], state[6]) + SHA256_K[i] + W[i];\n        var T2 = SHA256_Sigma0(state[0])
  + SHA256_Maj(state[0], state[1], state[2]);\n        state.pop();\n        state.unshift((T1
  + T2) & 0xffffffff);\n        state[4] = (state[4] + T1) & 0xffffffff;\n      }\n
  \     for(var i = 0; i < 8; i++)\n        H[i] = (H[i] + state[i]) & 0xffffffff;\n
  \   }\n\n    function SHA256_Hash_Byte_Block(H, w) {\n      var W = new Array(16);\n
  \     for(var i = 0; i < 16; i++)\n        W[i] = w[4 * i + 0] << 24 | w[4 * i +
  1] << 16 |\n          w[4 * i + 2] << 8 | w[4 * i + 3];\n      SHA256_Hash_Word_Block(H,
  W);\n    }\n\n    /**************************** HMAC_SHA256 end *******************************/\n\n
  \ /**************************** REGEX FORMATTING *******************************/\n\n
  \   var ipRegex = /\\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\b/;\n
  \   var emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/;\n
  \   var hashRegex = /[a-fA-F0-9]/;\n    var md5Regex = /\\b[a-fA-F\\d]{32}\\b/gm;\n
  \   var sha1Regex = /\\b[a-fA-F\\d]{40}\\b/gm;\n    var sha256Regex = /\\b[a-fA-F\\d]{64}\\b/gm;\n\n
  \ /**************************** REGEX FORMATTING end *******************************/"
type: javascript
tags:
- infra
- server
comment: Common code that will be merged into each server script when it runs
system: true
scripttarget: 0
runonce: false
